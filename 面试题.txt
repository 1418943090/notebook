抽象类和接口的区别:

   抽象类  包含抽象方法的类
      不能创建实例，有构造方法，可以实现一些方法，
   接口
     接口中的变量会被隐式地指定为public static final变量（并且只能是public static final变量，
      没有构造器，不能实现方法，所有的方法都是public abstract修饰，属性都是static 
      接口和接口之间可以多继承
      jdk 8 java 可以有静态方法
------------------------------------------------------------------------------------------------
java io  采用了什么设计模式

装饰模式和适配器模式
Java I/O库的总体设计是符合装饰模式和适配器模式的。如前所述，这个库中处理流的类叫流类。
　　装饰模式：在由InputStream、OutputStream、Reader和Writer代表的等级结构内部，有一些流处理器可以对另一些流处理器起到装饰作用，形成新的、具有改善了的功能的流处理器。
　　适配器模式：在由InputStream、OutputStream、Reader和Writer代表的等级结构内部，有一些流处理器是对其他类型的流处理器的适配。这就是适配器的应用。
-----------------------------------------------------------------------------
值传递（pass by value）是指在调用函数时将实际参数复制一份传递到函数中，这样在函数中如果对参数进行修改，将不会影响到实际参数。
java中只有值传递 
引用传递（pass by reference）是指在调用函数时将实际参数的地址直接传递到函数中，那么在函数中对参数所进行的修改，将影响到实际参数。

------------------------------------------------------------------------
线程和进程的区别
   都是操作系统资源管理方式
   进程是资源分配和调度的一个独立单元
   线程是cpu调度的基本单元
 -----------------------------------------------------------------------
 ''stringBuffer 没有重写equals()方法
 StringBuffer s  = new StringBuffer("aaaa");
 StringBuffer s1 = new StringBuffer("aaaa);
 s.equals(s1); 返回false

 ------------------------------------------------------------------------
 HashMap   LinkedHashMap
 HashMap不保证数据插入顺序和输出顺序相同
 LinkedHashMap弥补了这个不足
 以双向链表维护键值对的次序
 ------------------------------------------------------------------------
 Map接口派生了一个SortMap子接口,SortMap的实现类是TreeMap.TreeMap
 也是基于红黑二叉树对所有的key进行排序，有两种排序方式:自然排序和定制排序。

 WeakHashMap
 WeakHashMap与HashMap的用法基本相同,
 区别在于：后者的key保留对象的强引用，即只要HashMap对象不被销毁，
 其对象所有key所引用的对象不会被垃圾回收，HashMap也不会自动删除这些key所对应的键值对对象。
 但WeakHashMap的key所引用的对象没有被其他强引用变量所引用，则这些key所引用的对象可能被回收。
 WeakHashMap中的每个key对象保存了实际对象的弱引用，
 当回收了该key所对应的实际对象后，WeakHashMap会自动删除该key所对应的键值对。
 IdentityHashMap
 IdentityHashMap与HashMap基本相似，只是当两个key严格相等时 即key1==key2时，它才认为两个key是相等的。

 比如String s1 = new String("aaa");
     String s2 = new String("aaa");
 EnumMap

 EnumMap中所有key都必须是单个枚举类的枚举值，创建EnumMap时必须显示或隐式指定它对应的枚举类

 EnumMap根据key的自然排序，即枚举类在枚举类中定义的顺序，来维护键值对的次序
 EnumMap不允许使用null作为key值，但value可以

 ConcurrentHashMap

 用于优化HashTable的锁机制 
 锁分离技术，将锁的粒度降低，利用多个锁控制多个小的table
 ---------------------------------------------------------------------
 java内置锁

 同步锁 
 互斥锁->当多个线程对同一个共享资源访问时，只能有一个线程可以获得该共享资源的锁。
 -------------------------------------------------------------------
 偏向锁
 偏向锁是JDK1.6提出来的一种锁优化的机制，其核心思想是，如果程序没有竞争，则取消之前已经取得锁的线程同步操作。
 。也就是说，若某一锁被线程获取后，便进入偏向模式，当线程再次请求这个锁时，就无需再进行相关的同步操作了，
 从而节约了操作时间，如果在此之前有其他的线程进行了锁请求。则锁退出偏向模式。
 --------------------------------------------------------------------------------------
 轻量级锁

 重量级锁

 自旋锁
      自旋锁可以使线程在没有取得锁的时候，不被挂起，
    而转去执行一个空循环，（即所谓的自旋，就是自己执行空循环）
    ，若在若干个空循环后，线程如果可以获得锁，则继续执行。若线程依然不能获得锁，才会被挂起。
    使用自旋锁后，线程被挂起的几率相对减少，
    线程执行的连贯性相对加强。因此，对于那些锁竞争不是很激烈，
    锁占用时间很短的并发线程，具有一定的积极意义，但对于锁竞争激烈，单线程锁占用很长时间的并发程序，
    自旋锁在自旋等待后，往往毅然无法获得对应的锁，不仅仅白白浪费了CPU时间，最终还是免不了被挂起的操作 ，反而浪费了系统的资源。
-----------------------------------------------------------------------------------------------------------------------------
什么是可重入性

可重入的函数必须满足以下三个条件
   (1)可以在执行的过程中被打断
   (2)被打断之后，在该函数一次调用执行完之前，可以再次被调用。
   (3)再次调用执行完之后，被打断的上次调用可以继续恢复执行，并正确执行。
可重入函数可以在任意时刻被中断，稍后再继续执行，不会丢失数据。不可重入函数不能由超过一个任务所共享
除非能确保函数的互斥
维基百科(可重入性)
    若一个程序或子程序可以“在任意时刻被中断然后操作系统调度执行另外一段代码，
    这段代码又调用了该子程序不会出错”，则称其为可重入（reentrant或re-entrant）的。
    即当该子程序正在运行时，执行线程可以再次进入并执行它，
    仍然获得符合设计时预期的结果。与多线程并发执行的线程安全不同，可重入强调对单个线程执行时重新进入同一个子程序仍然是安全的。
可重入的条件
  (1)不在函数内使用静态或全局数据
  (2)不返回静态或全局数据，所有数据都由函数的调用者提供
  (3)使用本地数据
  (4)不调用不可重入函数
----------------------------------------------------------------------------------------------------------------------------
Synchronized的可重入性

  synchroinzed拥有强制原子性的内部锁机制，是一个可重入锁，因此，在一个线程使用
  synchronized方法调用该对象另一个synchronized方法，即一个线程得到一个对象锁后再次请求该对象锁
  是永远可以拿到锁的。
  在Java内部，同一个线程调用自己类中其他synchronized方法/块时不会阻碍该线程的执行，同一个线程对同一个对象锁是可重入的，
  同一个线程可以获取同一把锁多次，也就是可以多次重入。原因是Java中线程获得对象锁的操作是以线程为单位的，而不是以调用为单位的。
-----------------------------------------------------------------------------------------------------------------------------
2.2. synchronized可重入锁的实现
之前谈到过，每个锁关联一个线程持有者和一个计数器。当计数器为0时表示该锁没有被任何线程持有
,那么任何线程都都可能获得该锁而调用相应方法。当一个线程请求成功后,JVM会记下持有锁的线程，
并将计数器计为1。此时其他线程请求该锁，则必须等待。而该持有锁的线程如果再次请求这个锁，
就可以再次拿到这个锁,同时计数器会递增。
当线程退出一个synchronized方法/块时,计数器会递减,如果计数器为0则释放该锁。

------------------------------------------------------------------------------------------

显示锁Lock跟隐式锁synchronized对比
    Synchronized是Java的关键字，当它用来修饰一个方法或一个代码块时，能够保证在同一时刻最多只有一个线程
   执行该代码。因为当调用synchronized修饰的代码时，并不需要显示的加锁和解锁的过程，所以称之为隐式锁。

   Lock是一个接口，提供了无条件的，可轮询的，定时的，可中断的锁获取操作。所有的加锁和解锁操作都是显示的
   所以称为显示锁。
'------------------------------------------------------------------------------------------------------
   ReentrantLock(可重入锁)唯一实现了Lock接口的类
----------------------------------------------------------------------------------------------
'
   不同点:
       (1)Lock是一个接口，而synchronized是java的关键字，是内置的语言实现，是在jvm层面上实现的。
          不但可以通过一些监控工具监控synchronized的锁定，而且在代码执行时出现异常，JVM会自动释放锁定
          但是Lock则不行,lock是通过代码实现的，要保证锁定一定会被释放，就必须将unLock()放到finally{}中;
       (2)synchronized在发生异常时会自动释放资源，因此不会导致死锁现象的发生；
          而Lock在发生异常时，如果没有主动通过unlock()去释放锁，则很有可能造成死锁现象，
          因此使用Lock时需要在finally块中释放锁；
       (3)Lock可以让等待锁的线程响应中断，线程可以中断去干别的事务，
          而synchronized却不行，使用synchronized时等待的线程会一直等待下去，不能够响应中断。
       (4)通过Lock可以知道有没有成功获得锁，而synchronized却无法办到
       (5)Lock可以提高多个线程进行读操作的效率
因此就需要一种机制来使得多个线程都只是进行读操作时，线程之间不会发生冲突，通过Lock就可以办到。
'------------------------------------------------------------------------------------------------
'synchronized的语义是互斥锁，就是在同一时刻
只有一个线程能获得执行代码的锁。但是现实生活中，有好多的场景，锁不止一把。
比如说，又到了十一假期，买票是重点，必须圈起来。
在购票大厅里，有5个售票窗口，也就是说同一时刻可以服务5个人。
要实现这种业务需求，用synchronized显然不合适。
查看Java并发工具，发现有一个Semaphore类，天生就是处理这种情况的。
先用Semaphore实现一个购票的小例子，来看看如何使用
Semaphore
AbstractQueuedSynchronizer
'------------------------------------------------------------------------------------------
一个线程从wait()状态醒来是不是一定被notify()了？
--------------------------------------------------------------------------------------
为什么这些操作线程的方法要定义在object类中呢？

简单说：因为synchronized中的这把锁可以是任意对象，所以任意对象都可以调用wait()和notify()；所以wait和notify属于Object。

专业说：因为这些方法在操作同步线程时，都必须要标识它们操作线程的锁，只有同一个锁上的被等待线程，可以被同一个锁上的notify唤醒，不可以对不同锁中的线程进行唤醒。

也就是说，等待和唤醒必须是同一个锁。而锁可以是任意对象，所以可以被任意对象调用的方法是定义在object类中。
-------------------------------------------------------------------------------------------------------------
事务
  原子性，一致性，独立性(隔离性)，持久性

  事务的四种隔离级别
      (1)Read uncommitted 读未提交
         事例：老板要给程序员发工资，程序员的工资是3.6万/月。
         但是发工资时老板不小心按错了数字，按成3.9万/月，该钱已经打到程序员的户口，
         但是事务还没有提交，就在这时，程序员去查看自己这个月的工资，发现比往常多了3千元，
         以为涨工资了非常高兴。但是老板及时发现了不对，马上回滚差点就提交了的事务，将数字改成3.6万再提交。
分析：实际程序员这个月的工资还是3.6万，但是程序员看到的是3.9万。他看到的是老板还没提交事务时的数据。这就是脏读'。
        Read commit 读提交，能解决脏读问题
      (2)Read commit 就是一个事务要等另一个事务提交后才能读取数据

          读提交，顾名思义，就是一个事务要等另一个事务提交后才能读取数据。

          事例：程序员拿着信用卡去享受生活（卡里当然是只有3.6万），当他埋单时（程序员事务开启），
		收费系统事先检测到他的卡里有3.6万，
		就在这个时候！！程序员的妻子要把钱全部转出充当家用，
		并提交。当收费系统准备扣款时，再检测卡里的金额，
		发现已经没钱了（第二次检测金额当然要等待妻子转出金额事务提交完）。
		程序员就会很郁闷，明明卡里是有钱的…
		分析：这就是读提交，若有事务对数据进行更新（UPDATE）操作时，
		读操作事务要等待这个更新操作事务提交后才能读取数据，可以解决脏读问题
		。但在这个事例中，出现了一个事务范围内两个相同的查询却返回了不同数据，这就是不可重复读'。

      (3)Repeateable read 重复读，就是在开始读取数据（事务开启）时，不再允许修改操作
       重复读，就是在开始读取数据（事务开启）时，不再允许修改操作
       事例：程序员拿着信用卡去享受生活（卡里当然是只有3.6万），
       当他埋单时（事务开启，不允许其他事务的UPDATE修改操作），
       收费系统事先检测到他的卡里有3.6万。这个时候他的妻子不能转出金额了。
       接下来收费系统就可以扣款了。
       分析：重复读可以解决不可重复读问题。写到这里，应该明白的一点就是，
       不可重复读对应的是修改，即UPDATE操作。但是可能还会有幻读问题'。
       因为幻读问题对应的是插入INSERT操作，而不是UPDATE操作。
'什么时候会出现幻读？'
事例：程序员某一天去消费，花了2千元，然后他的妻子去查看他今天的消费记录（全表扫描FTS，妻子事务开启），
看到确实是花了2千元，就在这个时候，程序员花了1万买了一部电脑，
即新增INSERT了一条消费记录，并提交。当妻子打印程序员的消费记录清单时（妻子事务提交），
发现花了1.2万元，似乎出现了幻觉，这就是幻读。
      (4) Serializable 序列化
          Serializable是最高的事务隔离级别，在该级别下事务串行化顺序执行，可以避免脏读，不可重复读与
          幻读，但是这种事务隔离级别效率低下，比较耗数据库性能，一般不使用
    值得一提的是:大多数数据库默认的事务隔离级别是Read Commit。比如Sql Server,Oracle.
               Mysql Repeatable read

------------------------------------------------------------------------------------------------------------------
（理解红黑树一句话就够了：红黑树就是用红链接表示3-结点的2-3树。
那么红黑树的插入、构造就可转化为2-3树的问题，即：在脑中用2-3树来操作，得到结果
，再把结果中的3-结点转化为红链接即可。而2-3树的插入，前面已有详细图文，实际也很简单：有空则插，没空硬插，再分裂。  
这样，我们就不用记那么复杂且让人头疼的红黑树插入旋转的各种情况了。只要清楚2-3树的插入方式即可。  下面图文详细演示。）

红黑树是对2-3查找树的改进，它能用一种统一的方式完成所有变换。

'--红链接将将两个2-结点连接起来构成一个3结点。

https://blog.csdn.net/yang_yulei/article/details/26066409
------------------------------------------------------------------------------------
Socket套接字
端口号拼接到ip地址即构成了套接字。
每一条TCP连接唯一地被通信两端的两个端点(两个套接字)所确定。
----------------------------------------------------------------
mvc 编程模式
model (模型)标示应用程序核心(比如数据库记录列表)
view  (视图)显示数据(数据库记录)
controller (控制器)处理输入(写入数据库记录)
将view与model分离。通过controller控制器进行交互
--------------------------------------------
访问权限              类  包  子类  其他包

  　　　　  public     ∨   ∨    ∨     ∨          （对任何人都是可用的）

   　　　　 protect    ∨   ∨   ∨     ×　　　 （继承的类可以访问以及和private一样的权限）

   　　　　 default    ∨   ∨   ×     ×　　　 （包访问权限，即在整个包内均可被访问）

   　　　　 private    ∨   ×   ×     ×　　　 （除类型创建者和类型的内部方法之外的任何人都不能访问的元素）
 -----------------------------------------------------------------------------------------------
  非对称加密算法
      
      非对称加密算法需要有两个密钥:
         公开密钥，私有密钥。
       公开密钥与私有密钥是一对。如果用公开密钥对数据进行加密，只有用对应的私有密钥才能解密;
       如果用私有密钥对数据进行加密，那么只有用对应的公开密钥才能解密。
       因为加密和解密使用的是两个不同的密钥，所以这种算法叫作非对称加密算法。

 --------------------------------------------------------------------------------
  对称加密
      在对称加密算法中，数据发送方将明文(原始数据)和加密密钥，一起经过特殊加密算法处理后
      使其变成复杂的加密密文发送出去。收信方收到密文后，若要解读原文，则需要使用加密用过的、
      密钥及相同算法的逆算法对密文进行解密，才能使其恢复成可读明文。
